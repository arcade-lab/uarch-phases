\section{Introduction}

Program phase analysis has a history dating back to the 1960s where the notion of a working set (recently referenced objects) was introduced and applied to multi-programmed memory management~\cite{Glaser:1965:SDC}. Since that time, phase analysis has been applied to an extensive application space. A common application of phase analysis is guiding dynamic hardware reconfiguration policies. Some examples include configurable caches/tlbs~\cite{903259}\cite{Veidenbaum:1999:ACL}\cite{Albonesi:1999:SCW}, allocation of memory hierarchy resources~\cite{Balasubramonian:2000:MHR}\cite{Ranganathan:2000:RCA}, allocation of memory buffer resources~\cite{Veidenbaum:1999:ACL}, configurable branch predictors~\cite{694771}, configurable instruction windows~\cite{Buyuktosunoglu:2000:AIQ}\cite{Folegnani00reducingpower}, and configurable pipelines~\cite{Bahar:2001:PER}.  Other applications of phase analysis includes power reduction~\cite{Huang:2003:PAP}\cite{Isci:2006:PCP}, data cache prefetching~\cite{Lu:2003:PRD}, accelerating architecture simulations~\cite{Sherwood:2002:ACL}\cite{Perelman:2003:PSV}\cite{Lau:2006:SSP}\cite{Perelman:2006:DPP}, data race detection~\cite{Marino:2009:LES}, and invoking garbage collection~\cite{Xian:2007:MAP}. This very rich application space underscores the need for continued research in phase analysis to improve upon existing state-of-the-art phase detection techniques.

Prior research on program phase detection has studied the problem at a relatively coarse level of granularity, detecting phases at a resolution of several thousands to millions of program cycles~\cite{Lau:2005:MVL}\cite{Huffmire:2006:WPC}\cite{Isci:2006:PCP}.  This is partly because phase detection mechanisms account for operating system context switch overheads that can be on the order of millions of cycles. The phases that are analyzed in the current study are much more fine-grained patterns of program behavior that occur over intervals that are much shorter than millions of program cycles. These shorter phases should be applied to situations where associated overheads are much shorter then overheads usually incurred by the operating system (e.g. dynamic hardware reconfiguration). 

Prior studies suggests that fine-grained phase analysis incurs high overheads while providing modest returns~\cite{Magklis:2003:PDV}\cite{Huang:2003:PAP}. We contend that phase detection overheads can be mitigated by more efficient hardware designs. Continued efforts to reduce overheads due to resource reconfiguration also cut into the overall costs. As a noted example, research has shown that DVS  can incur overheads on the order of just tens of nanoseconds (rather then microseconds) now with the help of on-chip switching regulators~\cite{Kim:2011:FLD}\cite{Kim:2008:HPC}. The underlying question, which is outside the scope this study, is what overhead levels can be tolerated by super fine-grained (SFG) phase analysis. The focus of the present study is to characterize these SFG phases and to begin to investigate promising application spaces. 

The task of detecting SFG phases can be considered within the much broader context of the phase shift detection (PSD) problem. The PSD problem takes as input a profile that encodes the time varying execution behavior of a program (along with a set of inputs stipulating how phases will be detected) and outputs a partitioning of the profile into periods of phases and phase transitions. Phases indicate periods of execution with similar behavior. The PSD problem input parameters are set by the client. The client can be any entity that utilizes the output of the PSD problem towards some purpose. The client has a producer-consumer like relationship within the PSD framework. We are interested in an instance of the PSD problem that will generate SFG phases, which are phases that will last for just tens or up to a few million of program cycles.

The input parameters to the PSD problem specifying how phases will be detected have previously been classified into two categories: \emph{granularity} and \emph{similarity}~\cite{Hind03phaseshift}. The granularity precisely defines the characteristics of the units that are compared for similarity. The similarity parameter defines a boolean function that computes whether two strings are similar or not based on a given threshold. The current study evaluates the SFG phases that emerge with relatively short interval size (granularity parameter) while also varying other similarity parameters. 

These are the overall goals of this research: 

\begin{enumerate}
\item Characterize SFG phases based on traditional and non-traditional models.
\item Compare and condtrast phases that emerge as parameters such as interval size and similarity thresholds change.
\item Specify application spaces that can benefit from using SFG phases.
\end{enumerate}



